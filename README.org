* EAZY-Project - Interactive Project Generator & Manager

This used to be a fork from cl-project@fukamachi, but since almost everything is
rewritten and added very much of new features, I renamed it as a new library.
It is focused on the interactive features.

Now quicklisp loadable: =(ql:quickload :eazy-project)=.

Usage:
#+BEGIN_SRC lisp
;; Include this statement in your .sbclrc / .ccl-init.lisp
(ignore-errors   ; this is odd, but in case.
  (ql:quickload :eazy-project)
  (use-package :eazy-project))

;; To launch a menu, enter "!" !
;; This is an alias to (launch-menu), using symbol-macrolet.
!

;; Then follow the instruction in the menu that appears in the debugger.
#+END_SRC

Tested on SBCL-1.2.1 x64 and CCL 1.9 x64.

** Tutorial: Restore the Yesterday's Coding Environment

Save and restore the set of currently loaded libraries.
In the main menu, select the =SESSION= submenu.

Main menu:
#+BEGIN_SRC 
(You are now in menu EP-MAIN.)
What to do next?
...
...
...
   [Condition of type EAZY-PROJECT:ASK]

Restarts:
 0: [SESSION] Save/Restore the currently loaded libraries
 1: [CREATE-PROJECT] Create a new project.
 2: [SET-GLOBAL] Modify these default values
 3: [UP] Back to the section EP-MAIN.
 4: [QUIT-SESSION] Quit this session.
 5: [RETRY] Retry SLIME REPL evaluation request.
#+END_SRC

SESSION submenu:
#+BEGIN_SRC 
(You are now in menu SESSION.)
What to do next?
   [Condition of type EAZY-PROJECT:ASK]

Restarts:
 0: [TOGGLE-WATCH] Watch and automatically save the session
 1: [ADD-DEFAULT-SYSTEM] Add-Default-System
 2: [SAVE] Save the current loaded session
 3: [ABORT] Return to sldb level 1.
 4: [UP] Back to the section EP-MAIN.
 5: [QUIT-MENU] Quit this eazy-project menu.
#+END_SRC

Then, SAVE or RESTORE the current session. SAVE will store the current
=*package*= and =asdf:already-loaded-systems= to a database for the later
restoration. RESTORE will restore the saved session. Finally, TOGGLE-WATCH
will initiate watching, which periodically initiate the SAVE command.

** Tutorial: Generate a project

First, open the menu.
The default data will have already been customized for you.
It should look something like below (depending on the implementation).

Now let's create a new project named "test".

#+BEGIN_SRC 
(You are now in menu EP-MAIN.)
What to do next?

Here are current default configs:
:SESSION.SYSTEMS     = (...
                        "fare-quasiquote")
:SESSION.PACKAGE     = "COMMON-LISP-USER"
:LOCAL-REPOSITORY    = #P"/mnt/video/guicho/repos/lisp/"
:SKELETON-DIRECTORY  = #P"/mnt/video/guicho/repos/lisp/eazy-project/skeleton"
:AUTHOR              = "Masataro Asai"
:EMAIL               = "guicho2.71828@gmail.com"
:GIT                 = T
:README-EXTENSION    = "md"
:SOURCE-DIR          = "src"
:TEST-DIR            = "t"
:TEST-SUBNAME        = "test"
:DELIMITER           = "."
:LICENSE             = "LLGPL"
:TEST                = :FIVEAM
:DEPENDS-ON          = (:ALEXANDRIA :OPTIMA :ITERATE)
   [Condition of type EAZY-PROJECT:ASK]

Restarts:
 0: [SESSION] Save/Restore the currently loaded libraries
 1: [CREATE-PROJECT] Create a new project.
 2: [SET-GLOBAL] Modify these default values
 3: [UP] Back to the section EP-MAIN.
 4: [QUIT-SESSION] Quit this session.
 5: [RETRY] Retry SLIME REPL evaluation request.
#+END_SRC

Noitice the several entries that could be added to your new project, e.g., 
:DEPENDS-ON, :AUTHOR, :EMAIL.

+ These default variables can be customized by proceeding to the submenu
  =EP-MAIN -> SET-GLOBAL=. You will be prompted to enter the value of each
  field.
+ The default dependency can also be modified by editing the customization
  file directly. It is saved in =<eazy-project-repo>/default-config.lisp=,
  which is also available in =eazy-project:*config-path*=.

After adding the global dependency, say TRIVIAL-SHELL,
then select =CREATE-PROJECT=. A new debugger menu would appear. 

#+BEGIN_SRC 
(You are now in menu CREATE-PROJECT.)
Select and enter the information, then select 'CREATE'.
Current global configuration:
....

Current local configuration:
(no configuration specified)
   [Condition of type EAZY-PROJECT:ASK]

Restarts:
 0: [CREATE] Create
 1: [RESET-LOCAL-CONFIG] Reset the current local config
 2: [ADD-LOCAL-DEPENDENCY] Add-Local-Dependency
 3: [NAME] Name
...
#+END_SRC

In this submenu, you can further modify several /project-local/
configurations. These configurations are not saved across sessions.

+ Select =NAME= to enter the name of the new project, now "test". (if when
  you attempt to create a project without it, the generator complains and
  opens an interactive prompt).
+ You can further add the dependencies in ADD-LOCAL-DEPENDENCY submenu.
  + The project-local dependency is a dependency only for this project.

Finally, select =CREATE=. It will set up the repository, initialize the
repo with git (by default. It can be disabled) and load it.

** TODO Using Programatically

Although it is possible, the interface is not well structured.
For automated testing, I have =simulate-menu-selection=.

#+BEGIN_SRC lisp
(simulate-menu-selection
  `((eazy-project::create-project)
    (:name "test")
    (eazy-project::create)))
#+END_SRC

In the near future, I plans to separate the basis of the interactive
feature, named =defmenu=, as an independent library.

** TODO Skeletons

Skeleton of the new project is currently not customizable, unlike original
=cl-project=.

** TODO lisp-n

Another back-end I plan to separate from eazy-project is called =lisp-n=,
which is a simple wrapper layer for defining a namespace.

We see many systems which implements their own =defXXX=,
and each time they use symbol-plist or a hashtable.
=lisp-n= is a layer which abstracts the concept of "namespace as hashtable".
For example, =(lisp-n:define-namespace X &optional type)= automatically defines

+ symbol-x and (setf symbol-x)
+ unbound-x
+ x-boundp

and add =ftype= proclamation to each functions.

Common lisp is lisp-2, which means it has a different namespaces for the
value and the function. With lisp-n, you can define arbitrary additional
namespaces and its accessors as well.

The idea is simple.  Common lisp has `symbol-value' and `symbol-function',
so I added `symbol-anything-you-like'.  Current implementation is
built upon a hashtable, but it also modifies `cl:symbol-plist', for the
debugging purpose. However, this symbol-plist feature is disabled when
=(< 2 S)= where =(declare (optimize (speed S)))=.

This is not yet separated because I further want to implement =nlet=, which
abstracts =let,macrolet,flet=. The idea is:

#+BEGIN_SRC lisp
  (nlet (((function sub) (arg) ...)       ; converted to flet
         ((function* rec) (arg) ...)      ; converted to labels
         ((macro m) (arg) ...)            ; converted to macrolet
         ((X thing) ...) ; converted to *lexical* binding of THING in namespace X
         (var       ...) ; converted to let
         ((symbol-macro var) ...))         ; converted to symbol-macrolet
    body...)
#+END_SRC

